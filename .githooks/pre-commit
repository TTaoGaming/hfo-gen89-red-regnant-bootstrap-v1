#!/bin/sh
# ─── HFO Gen90 Pre-Commit Hook ───────────────────────────────
# Gate: medallion boundary + root cleanliness + no secrets
# Install: git config core.hooksPath .githooks
# ──────────────────────────────────────────────────────────────

# ── 0. Anti-Bypass Firewall ──────────────────────────────────
# Prevent agents from using --no-verify to bypass this hook.
# If this script is running, it means the hook was triggered.
# We cannot prevent --no-verify from skipping the hook entirely,
# but we CAN prevent the CI/CD pipeline from accepting it.
# The CI/CD pipeline is the ultimate backstop.

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

ERRORS=0

echo "═══ HFO Gen90 Pre-Commit Gate ═══"

# ── 1. Root Cleanliness ──────────────────────────────────────
# Only allowed root files (no deep forge stuff leaking to root)
ALLOWED_ROOT="AGENTS.md|\.env\.example|\.gitignore|\.gitattributes|\.githooks|\.github|\.vscode|hfo_pointers\.py|hfo_gen_90_hot_obsidian_forge|hfo_gen_90_hot_obsidian_forge|LICENSE|README\.md|\.git|pytest\.ini|tests|features|_scratch|_demote_forge\.py|_freeze_gen90\.py|_scaffold_gen90\.py|_fix_para_gen90\.py"

STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

for f in $STAGED_FILES; do
    # Check if file is at root (no / in path means root-level)
    dir=$(dirname "$f")
    if [ "$dir" = "." ]; then
        base=$(basename "$f")
        if ! echo "$base" | grep -qE "^($ALLOWED_ROOT)$"; then
            echo "${RED}✗ ROOT VIOLATION:${NC} $f is not in the allowed root file list"
            echo "  Move to forge: hfo_gen_90_hot_obsidian_forge/0_bronze/"
            ERRORS=$((ERRORS + 1))
        fi
    fi
done

if [ $ERRORS -eq 0 ]; then
    echo "${GREEN}✓${NC} Root cleanliness OK"
fi

# ── 2. No Secrets ────────────────────────────────────────────
SECRET_PATTERNS="\.env$|\.hfo_secret|\.pem$|\.key$|password|api_key|secret_key"

for f in $STAGED_FILES; do
    if echo "$f" | grep -qiE "$SECRET_PATTERNS"; then
        # .env.example is allowed
        if [ "$f" != ".env.example" ]; then
            echo "${RED}✗ SECRET LEAK:${NC} $f matches secret pattern"
            ERRORS=$((ERRORS + 1))
        fi
    fi
done

if [ $ERRORS -eq 0 ]; then
    echo "${GREEN}✓${NC} No secret filenames staged"
fi

# ── 2b. Content Scanning for Secrets ─────────────────────────
# Scan staged file contents for hardcoded API keys, tokens, passwords
# Require that the value IS quoted (avoids false positives on variable references)
CONTENT_SECRET_PATTERNS='(BRAVE_API_KEY|TAVILY_API_KEY|GITHUB_PERSONAL_ACCESS_TOKEN|GITHUB_TOKEN|OPENAI_API_KEY|ANTHROPIC_API_KEY|HFO_SECRET)\s*[=:]\s*["\x27][A-Za-z0-9_\-\.]{16,}'

for f in $STAGED_FILES; do
    # Only scan text files, skip binaries and .env.example
    if [ "$f" = ".env.example" ]; then continue; fi
    if [ -f "$f" ]; then
        CONTENT=$(git diff --cached --diff-filter=ACM -p -- "$f" 2>/dev/null | grep '^+' | grep -v '^+++' || true)
        if echo "$CONTENT" | grep -qiE "$CONTENT_SECRET_PATTERNS"; then
            echo "${RED}✗ SECRET IN CONTENT:${NC} $f contains what looks like a hardcoded secret/API key"
            echo "  Use environment variables or .env (gitignored) instead of committing secrets."
            ERRORS=$((ERRORS + 1))
        fi
    fi
done

if [ $ERRORS -eq 0 ]; then
    echo "${GREEN}✓${NC} No secrets in file contents"
fi

# ── 3. Medallion Boundary ────────────────────────────────────
# DENY-BY-DEFAULT: Bronze cannot self-promote. Operator bypasses with:
#   HFO_BYPASS_MEDALLION=1 git commit -m '...'
if [ "${HFO_BYPASS_MEDALLION:-0}" = "1" ]; then
    echo "${YELLOW}⚠ MEDALLION GATE BYPASSED${NC} (HFO_BYPASS_MEDALLION=1) — operator commit"
else
    for f in $STAGED_FILES; do
        case "$f" in
            *1_silver/*|*2_gold/*|*3_hyper_fractal_obsidian/*)
                echo "${RED}✗ MEDALLION VIOLATION:${NC} $f — direct write to non-bronze layer"
                echo "  Operator override: HFO_BYPASS_MEDALLION=1 git commit -m '...'"
                ERRORS=$((ERRORS + 1))
                ;;
        esac
    done
fi

# ── 4. Large File Gate ───────────────────────────────────────
# Files >10 MB blocked unless they are known large assets (.sqlite = SSOT DB).
# For the SSOT DB use: git lfs track "*.sqlite" before staging.
for f in $STAGED_FILES; do
    if [ -f "$f" ]; then
        size=$(wc -c < "$f" 2>/dev/null || echo 0)
        case "$f" in
            *.sqlite)
                if [ "$size" -gt 314572800 ]; then  # 300 MB hard cap on SSOT DB
                    echo "${RED}✗ SQLITE TOO LARGE:${NC} $f ($(($size / 1048576)) MB) > 300 MB. Consider archiving old stigmergy events."
                    ERRORS=$((ERRORS + 1))
                elif [ "$size" -gt 10485760 ]; then
                    echo "${YELLOW}⚠ LARGE SQLITE:${NC} $f ($(($size / 1048576)) MB) — consider Git LFS: git lfs track \"*.sqlite\""
                fi
                ;;
            */archives/*)
                # Bronze archives are expected large artifacts (concat/compilation outputs)
                if [ "$size" -gt 52428800 ]; then  # 50 MB hard cap on archives
                    echo "${RED}✗ ARCHIVE TOO LARGE:${NC} $f ($(($size / 1048576)) MB) > 50 MB."
                    ERRORS=$((ERRORS + 1))
                elif [ "$size" -gt 10485760 ]; then
                    echo "${YELLOW}⚠ LARGE ARCHIVE:${NC} $f ($(($size / 1048576)) MB) — consider Git LFS: git lfs track \"$(basename $f)\""
                fi
                ;;
            *)
                if [ "$size" -gt 10485760 ]; then
                    echo "${RED}✗ LARGE FILE:${NC} $f ($(($size / 1048576)) MB) — files >10MB must use Git LFS."
                    ERRORS=$((ERRORS + 1))
                fi
                ;;
        esac
    fi
done

# ── 5. Content Scanning for Private Keys / PEMs ───────────────
# Immediately block any staged content that contains private key material.
KEY_PATTERNS='-----BEGIN (RSA |EC |OPENSSH |DSA |ENCRYPTED )?PRIVATE KEY-----|-----BEGIN CERTIFICATE-----|PRIVATE KEY'
for f in $STAGED_FILES; do
    # Skip binary blobs check if file missing in worktree
    if [ -f "$f" ] && [ "$f" != ".githooks/pre-commit" ]; then
        CONTENT_ADDS=$(git diff --cached --diff-filter=ACM -p -- "$f" 2>/dev/null | grep '^+' | grep -v '^+++' || true)
        if echo "$CONTENT_ADDS" | grep -qE -- "$KEY_PATTERNS"; then
            echo "${RED}✗ PRIVATE KEY DETECTED:${NC} $f contains key/certificate material"
            ERRORS=$((ERRORS + 1))
        fi
    fi
done

# ── 6. Omega v13 Lint & Zod Gate ────────────────────────────
# If ESLint is configured in the microkernel project, run it on staged TS files.
OMEGA_DIR="hfo_gen_90_hot_obsidian_forge/1_silver/projects/omega_v13_microkernel"
OMEGA_ESLINT="$OMEGA_DIR/eslint.config.mjs"
OMEGA_STAGED_TS=$(echo "$STAGED_FILES" | tr ' ' '\n' | grep -E "$OMEGA_DIR/.*\.tsx?$" || true)

# ── 6.5. Orchestrator Guillotines (Fail-Closed Genesis) ───────
if [ -n "$OMEGA_STAGED_TS" ]; then
    echo "► Running Orchestrator Guillotines on Omega v13..."
    # Run the guillotines script
    if command -v pwsh >/dev/null 2>&1; then
        pwsh -File "_scratch/run_gates.ps1"
        GUILLOTINE_EXIT=$?
    elif command -v powershell >/dev/null 2>&1; then
        powershell -File "_scratch/run_gates.ps1"
        GUILLOTINE_EXIT=$?
    else
        echo "${YELLOW}⚠ GUILLOTINES SKIPPED:${NC} PowerShell not found."
        GUILLOTINE_EXIT=0
    fi

    if [ $GUILLOTINE_EXIT -ne 0 ]; then
        echo "${RED}✗ GUILLOTINES FAILED:${NC} The Swarm is lying. Fix the Potemkin Antipatterns."
        ERRORS=$((ERRORS + 1))
    else
        echo "${GREEN}✓${NC} Orchestrator Guillotines passed"
    fi
fi

if [ -f "$OMEGA_ESLINT" ] && [ -n "$OMEGA_STAGED_TS" ]; then
    echo "► Running Omega v13 ESLint on staged TypeScript files..."
    if command -v npx >/dev/null 2>&1; then
        # We need to pass paths relative to OMEGA_DIR to eslint
        REL_PATHS=$(echo "$OMEGA_STAGED_TS" | sed "s|^$OMEGA_DIR/||")
        ( cd "$OMEGA_DIR" && npx eslint --max-warnings=0 $REL_PATHS 2>&1 )
        LINT_EXIT=$?
        if [ $LINT_EXIT -ne 0 ]; then
            if [ "${HFO_BYPASS_LINT:-0}" = "1" ]; then
                echo "${YELLOW}⚠ OMEGA-LINT:${NC} ESLint violations found but bypassed (HFO_BYPASS_LINT=1)"
            else
                echo "${RED}✗ OMEGA-LINT:${NC} ESLint found arch violations. Fix before committing."
                echo "  Operator override: HFO_BYPASS_LINT=1 git commit -m '...'"
                ERRORS=$((ERRORS + 1))
            fi
        else
            echo "${GREEN}✓${NC} Omega v13 ESLint clean"
        fi
        
        echo "► Running Omega v13 Zod Schema Tests..."
        ( cd "$OMEGA_DIR" && npm run test:zod 2>&1 )
        ZOD_EXIT=$?
        if [ $ZOD_EXIT -ne 0 ]; then
            if [ "${HFO_BYPASS_LINT:-0}" = "1" ]; then
                echo "${YELLOW}⚠ OMEGA-ZOD:${NC} Zod tests failed but bypassed (HFO_BYPASS_LINT=1)"
            else
                echo "${RED}✗ OMEGA-ZOD:${NC} Zod schema tests failed. Fix before committing."
                echo "  Operator override: HFO_BYPASS_LINT=1 git commit -m '...'"
                ERRORS=$((ERRORS + 1))
            fi
        else
            echo "${GREEN}✓${NC} Omega v13 Zod schemas valid"
        fi
    fi
elif [ -n "$OMEGA_STAGED_TS" ] && [ ! -f "$OMEGA_ESLINT" ]; then
    echo "${YELLOW}⚠ OMEGA-LINT:${NC} TypeScript staged but no eslint.config.mjs yet — skipping (add ESLint to enforce arch boundaries)"
fi

# ── 7. Python Pytest Gate (Correct-by-Construction) ──────────
# If any Python files are staged, run pytest to ensure tests pass.
PY_STAGED=$(echo "$STAGED_FILES" | tr ' ' '\n' | grep -E "\.py$" || true)
if [ -n "$PY_STAGED" ]; then
    echo "► Running Pytest Gate on Python files..."
    if command -v pytest >/dev/null 2>&1; then
        pytest --maxfail=1 --disable-warnings -q
        PYTEST_EXIT=$?
    elif [ -f ".venv/Scripts/pytest.exe" ]; then
        .venv/Scripts/pytest.exe --maxfail=1 --disable-warnings -q
        PYTEST_EXIT=$?
    else
        echo "${YELLOW}⚠ PYTEST SKIPPED:${NC} pytest not found in PATH or .venv."
        PYTEST_EXIT=0
    fi

    if [ $PYTEST_EXIT -ne 0 ]; then
        if [ "${HFO_BYPASS_TESTS:-0}" = "1" ]; then
            echo "${YELLOW}⚠ PYTEST:${NC} Tests failed but bypassed (HFO_BYPASS_TESTS=1)"
        else
            echo "${RED}✗ PYTEST FAILED:${NC} Correct-by-Construction genesis requires passing tests."
            echo "  Operator override: HFO_BYPASS_TESTS=1 git commit -m '...'"
            ERRORS=$((ERRORS + 1))
        fi
    else
        echo "${GREEN}✓${NC} Pytest suite passed"
    fi
fi

# ── Result ────────────────────────────────────────────────────
if [ $ERRORS -gt 0 ]; then
    echo ""
    echo "${RED}═══ BLOCKED: $ERRORS error(s). Fix and retry. ═══${NC}"
    exit 1
else
    echo "${GREEN}═══ PASSED: All gates clear. ═══${NC}"
    exit 0
fi
