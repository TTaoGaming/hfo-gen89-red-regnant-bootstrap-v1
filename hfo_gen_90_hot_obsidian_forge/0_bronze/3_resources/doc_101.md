---
medallion_layer: gold
mutation_score: 0
hive: V
hfo_header_v3: compact
schema_id: hfo.diataxis.reference.obsidian_octave_8_signature_spells.v1
mnemonic: "OÂ·BÂ·SÂ·IÂ·DÂ·IÂ·AÂ·N = 8 ports = 8 spells = 8 schools"
bluf: "The OBSIDIAN Octave â€” 8 signature spells, one per port, one per D&D school. Each formalized with: spell details, HFO fit, JADC2/MOSAIC mapping, HFO metadata, and pseudocode grounded in real infrastructure."
primary_port: P7
role: "Cross-port â€” all 8 commanders"
tags: [gold, forge:hot, diataxis:reference, obsidian-octave, epic-spells, signature, all-ports, pseudocode, jadc2, mosaic, divine-adjacent]
diataxis_type: reference
cross_references:
  - "REFERENCE_LEGENDARY_COMMANDERS_EPIC_CLASSES_V1.md"
  - "REFERENCE_LEGENDARY_COMMANDER_ABILITIES_SPELLBOOK_V1.md"
  - "REFERENCE_EPIC_SPELL_PROPOSALS_PER_PORT_V1.md"
  - "REFERENCE_HFO_PANTHEON_DND_DR0_CHARACTER_SHEETS_V6.md"
  - "REFERENCE_OBSIDIAN_WEB_JADC2_MOSAIC_SOP_V1.md"
generated: "2026-02-16T16:10:00Z"
---

# THE OBSIDIAN OCTAVE â€” 8 Signature Spells (v1)

> *8 ports. 8 commanders. 8 D&D schools. 8 MOSAIC tiles.*
> *One spell each. No overlap. No gaps.*

## The Octave at a Glance

| Port | Commander | Spell | School | MOSAIC | Level |
|------|-----------|-------|--------|--------|-------|
| P0 | Lidless Legion | **TRUE SEEING** | Divination | SENSE | 6th |
| P1 | Web Weaver | **FORBIDDANCE** | Abjuration | FUSE | 6th |
| P2 | Mirror Magus | **GENESIS** | Conjuration (Epic) | SHAPE | Epic |
| P3 | Harmonic Hydra | **GATE** | Conjuration | DELIVER | 9th |
| P4 | Red Regnant | **WEIRD** | Illusion | DISRUPT | 9th |
| P5 | Pyre Praetorian | **CONTINGENCY** | Evocation | DEFEND | 6th |
| P6 | Kraken Keeper | **CLONE** | Necromancy | STORE | 8th |
| P7 | Spider Sovereign | **TIME STOP** | Transmutation | NAVIGATE | 9th |

---

## SPELL 1 â€” TRUE SEEING

### D&D Spell Details

| Field | Value |
|-------|-------|
| **Name** | True Seeing |
| **School** | Divination |
| **Level** | 6th (Cleric/Sorcerer-Wizard) |
| **Components** | V, S, M (ointment for eyes, 250 gp) |
| **Duration** | 1 min/level |
| **Range** | Touch |
| **Effect** | Subject sees through normal and magical darkness, notices secret doors, sees exact locations of displaced or ethereal creatures, sees through illusions, polymorphs, and transmutations. See things as they REALLY are. |
| **Epic Upgrade** | Greater True Seeing â€” penetrates even mind-affecting effects and divine deception. |

### HFO Fit

| Field | Value |
|-------|-------|
| **Commander** | Lidless Legion â€” WATCHER OF WHISPERS AND WRATH |
| **Port** | P0 OBSERVE |
| **Trigram** | â˜· Kun (Earth) â€” pure receptivity |
| **Strange Loop** | Whispers â†’ Wrath â†’ Detection â†’ Whispers |
| **Paradox** | Whispers ARE wrath â€” the signal ignored becomes the catastrophe |
| **Why This Spell** | The Watcher's ENTIRE identity is "see things as they really are." True Seeing is the purest expression of passive omniscience â€” you don't attack, you don't create, you simply SEE TRUTH. Anti-hallucination incarnate. |
| **Existing Ability** | None (this would be P0's first Lvl 1 ability) |

### JADC2 / MOSAIC

| Field | Value |
|-------|-------|
| **MOSAIC Tile** | SENSE |
| **JADC2 Function** | ISR (Intelligence, Surveillance, Reconnaissance) |
| **Kill Chain Stage** | Find â€” detect and identify targets of interest |
| **OODA Stage** | Observe â€” perceive environment accurately |
| **C2 Requirement** | Ground truth â€” command decisions require accurate sensor data |
| **Military Analog** | Electronic warfare â€” distinguishing real signals from jamming/spoofing |

### HFO Metadata

| Field | Value |
|-------|-------|
| **Script** | `scripts/lidless_legion_true_seeing.py` |
| **Pointer Key** | `p0_true_seeing_script` |
| **Artifact Dir** | `artifacts/lidless_legion_true_seeing/` |
| **State File** | `true_seeing_state.json` |
| **npm Scripts** | `p0:true-seeing:cast`, `p0:true-seeing:status`, `p0:true-seeing:gaze` |
| **Dependencies** | `scripts/red_regnant_orient.py`, `hfo_pointers.py`, `hfo_memory_guardrails.py` |
| **Galois Partner** | P7 TIME_STOP (Stage 0: what is real? + freeze to verify) |
| **MTG Card Slot** | Static â€” Cloudshredder Sliver (always-on sensing) |

### Pseudocode

```python
#!/usr/bin/env python3
"""
Ability: TRUE_SEEING | Level: 1 | Frequency: Daily
Commander: Lidless Legion (P0 OBSERVE)
"See things as they REALLY are."
"""
import subprocess, json, os, sys, hashlib
from pathlib import Path
from datetime import datetime

ARTIFACT_DIR = Path("artifacts/lidless_legion_true_seeing")
STATE_FILE = ARTIFACT_DIR / "true_seeing_state.json"

# â”€â”€ The 8 Veils (illusions to pierce) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
VEILS = [
    {
        "name": "SSOT Count Veil",
        "check": "ssot_count",
        "illusion": "SSOT says N alive but actual rows differ",
        "tier": "T2"
    },
    {
        "name": "Pointer Existence Veil",
        "check": "pointer_existence",
        "illusion": "Pointer resolves but target file is empty or missing",
        "tier": "T2"
    },
    {
        "name": "Script Runnable Veil",
        "check": "script_runnable",
        "illusion": "npm script defined but Python file has syntax error",
        "tier": "T2"
    },
    {
        "name": "Gate Armed Veil",
        "check": "gate_armed",
        "illusion": "Gate script exists but exit code is always 0 (never fails)",
        "tier": "T4"
    },
    {
        "name": "Receipt Freshness Veil",
        "check": "receipt_freshness",
        "illusion": "Receipts exist but none from last 7 days",
        "tier": "T4"
    },
    {
        "name": "Memory Staleness Veil",
        "check": "memory_staleness",
        "illusion": "Memories alive but oldest update > 30 days",
        "tier": "T4"
    },
    {
        "name": "Test Coverage Veil",
        "check": "test_coverage",
        "illusion": "130 Playwright tests but 0 run in last 14 days",
        "tier": "T6"
    },
    {
        "name": "AI Theater Veil",
        "check": "ai_theater",
        "illusion": "Agent claimed success but no file was actually written",
        "tier": "T6"
    },
]

def _resolve_ssot_db():
    """Resolve SSOT path via pointer system."""
    result = subprocess.run(
        ["python3", "hfo_pointers.py", "resolve", "mcp_memory_ssot_sqlite"],
        capture_output=True, text=True
    )
    return result.stdout.strip()

def _check_ssot_count(db_path):
    """Veil 0: Does reported count match actual rows?"""
    import sqlite3
    conn = sqlite3.connect(db_path)
    alive = conn.execute(
        "SELECT COUNT(*) FROM memories WHERE deleted_at IS NULL"
    ).fetchone()[0]
    total = conn.execute("SELECT COUNT(*) FROM memories").fetchone()[0]
    conn.close()
    # The "illusion" would be if orient reports different numbers
    orient_out = subprocess.run(
        ["python3", "scripts/red_regnant_orient.py"],
        capture_output=True, text=True, timeout=10
    )
    # Parse orient output for SSOT line
    for line in orient_out.stdout.splitlines():
        if "SSOT" in line and "alive" in line:
            # Extract reported alive count
            # Compare with actual
            return {"pass": True, "actual_alive": alive, "actual_total": total,
                    "orient_line": line.strip()}
    return {"pass": False, "reason": "Could not parse orient SSOT line"}

def _check_pointer_existence():
    """Veil 1: Do all blessed pointers actually resolve to existing files?"""
    result = subprocess.run(
        ["python3", "scripts/verify_hfo_pointers_blessed.py"],
        capture_output=True, text=True, timeout=30
    )
    passed = result.returncode == 0
    missing = []
    for line in result.stdout.splitlines():
        if "MISSING" in line or "NOT FOUND" in line:
            missing.append(line.strip())
    return {"pass": passed, "missing_count": len(missing), "missing": missing[:5]}

def _check_script_runnable():
    """Veil 2: Can key Python scripts actually parse without syntax errors?"""
    key_scripts = [
        "scripts/festering_anger_sweep.py",
        "scripts/pyre_praetorian_prismatic_wall.py",
        "scripts/spider_sovereign_wish.py",
        "scripts/red_regnant_prey.py",
        "hfo_hub.py",
    ]
    errors = []
    for script in key_scripts:
        result = subprocess.run(
            ["python3", "-m", "py_compile", script],
            capture_output=True, text=True
        )
        if result.returncode != 0:
            errors.append({"script": script, "error": result.stderr.strip()})
    return {"pass": len(errors) == 0, "errors": errors}

def _check_gate_armed():
    """Veil 3: Do gates actually fail when they should?"""
    # Check governance gate â€” it SHOULD fail (231 modes vs 3 cap)
    result = subprocess.run(
        ["python3", "scripts/hfo_governance_gate.py"],
        capture_output=True, text=True, timeout=30
    )
    # If governance gate returns 0, it's NOT armed (illusion!)
    governance_armed = result.returncode != 0
    return {
        "pass": governance_armed,
        "governance_gate_exit": result.returncode,
        "note": "Armed = returns non-zero when violations exist"
    }

def _check_receipt_freshness():
    """Veil 4: Are flight receipts recent or ancient?"""
    flight_dir = Path("artifacts/flight")
    if not flight_dir.exists():
        return {"pass": False, "reason": "No flight directory"}
    receipts = sorted(flight_dir.glob("*.json"), key=os.path.getmtime, reverse=True)
    if not receipts:
        return {"pass": False, "reason": "No receipts found"}
    newest = datetime.fromtimestamp(os.path.getmtime(receipts[0]))
    age_days = (datetime.now() - newest).days
    return {"pass": age_days <= 7, "newest_age_days": age_days,
            "total_receipts": len(receipts)}

def _check_memory_staleness(db_path):
    """Veil 5: Are memories being updated or rotting?"""
    import sqlite3
    conn = sqlite3.connect(db_path)
    newest = conn.execute(
        "SELECT MAX(updated_at_iso) FROM memories WHERE deleted_at IS NULL"
    ).fetchone()[0]
    oldest = conn.execute(
        "SELECT MIN(updated_at_iso) FROM memories WHERE deleted_at IS NULL"
    ).fetchone()[0]
    conn.close()
    return {"pass": True, "newest": newest, "oldest": oldest}

def _check_test_coverage():
    """Veil 6: When did Playwright tests last run?"""
    results_dir = Path("test-results")
    if not results_dir.exists():
        return {"pass": False, "reason": "No test-results directory"}
    # Check most recent result
    results = sorted(results_dir.iterdir(), key=os.path.getmtime, reverse=True)
    if not results:
        return {"pass": False, "reason": "Empty test-results"}
    newest = datetime.fromtimestamp(os.path.getmtime(results[0]))
    age_days = (datetime.now() - newest).days
    return {"pass": age_days <= 14, "newest_age_days": age_days}

def _check_ai_theater():
    """Veil 7: Check last N blackboard events for claims without proof."""
    bb_path = Path("hfo_hot_obsidian/hot_obsidian_blackboard.jsonl")
    if not bb_path.exists():
        bb_path = Path("hot_obsidian_forge/hot_obsidian_blackboard.jsonl")
    if not bb_path.exists():
        return {"pass": True, "note": "No blackboard found â€” cannot verify"}
    # Read last 20 events, check for "success" without file proof
    lines = bb_path.read_text().strip().splitlines()[-20:]
    suspect = 0
    for line in lines:
        try:
            evt = json.loads(line)
            data = evt.get("data", {})
            if "success" in str(data).lower() and "file" not in str(data).lower():
                suspect += 1
        except json.JSONDecodeError:
            pass
    return {"pass": suspect < 3, "suspect_events": suspect, "checked": len(lines)}

def cast():
    """Cast TRUE SEEING â€” pierce all 8 veils."""
    ARTIFACT_DIR.mkdir(parents=True, exist_ok=True)
    db_path = _resolve_ssot_db()

    print("=" * 66)
    print("  TRUE SEEING â€” Lidless Legion's Ground Truth Audit (Lvl 1)")
    print("  See things as they REALLY are.")
    print("=" * 66)

    checks = {
        "ssot_count": _check_ssot_count,
        "pointer_existence": _check_pointer_existence,
        "script_runnable": _check_script_runnable,
        "gate_armed": _check_gate_armed,
        "receipt_freshness": _check_receipt_freshness,
        "memory_staleness": lambda: _check_memory_staleness(db_path),
        "test_coverage": _check_test_coverage,
        "ai_theater": _check_ai_theater,
    }

    results = []
    for veil in VEILS:
        check_fn = checks.get(veil["check"])
        try:
            result = check_fn() if veil["check"] != "ssot_count" else check_fn(db_path)
            passed = result.get("pass", False)
        except Exception as e:
            result = {"pass": False, "error": str(e)}
            passed = False

        icon = "ðŸ‘ï¸" if passed else "ðŸ«£"
        tier_label = f"[{veil['tier']}]"
        print(f"\n  {icon} Veil {VEILS.index(veil)}: {veil['name']} {tier_label}")
        print(f"     Illusion: {veil['illusion']}")
        if passed:
            print(f"     Reality:  PIERCED â€” truth confirmed")
        else:
            print(f"     Reality:  ILLUSION DETECTED â€” {result}")
        results.append({"veil": veil["name"], "passed": passed, **result})

    pierced = sum(1 for r in results if r["passed"])
    total = len(results)

    if pierced == total:
        sight = "OMNISCIENT"
    elif pierced >= 6:
        sight = "CLEAR-SIGHTED"
    elif pierced >= 4:
        sight = "PARTIALLY BLIND"
    else:
        sight = "DECEIVED"

    print(f"\n{'â”€' * 66}")
    print(f"  Sight: {sight} ({pierced}/{total} veils pierced)")
    print("=" * 66)

    state = {
        "cast_at": datetime.utcnow().isoformat() + "Z",
        "sight": sight,
        "pierced": pierced,
        "total": total,
        "results": results,
    }
    STATE_FILE.write_text(json.dumps(state, indent=2, default=str))
    return state

def status():
    """Show last TRUE SEEING cast results."""
    if not STATE_FILE.exists():
        print("No TRUE SEEING cast found. Run: npm run p0:true-seeing:cast")
        return
    state = json.loads(STATE_FILE.read_text())
    print(f"Last cast: {state['cast_at']}")
    print(f"Sight: {state['sight']} ({state['pierced']}/{state['total']})")

def gaze(target=None):
    """Focus TRUE SEEING on a specific subsystem."""
    # Re-run a single veil check by name
    print(f"Gazing at: {target or 'all'}")
    cast()  # For Lvl 1, gaze = full cast. Lvl 2 adds targeted checks.

if __name__ == "__main__":
    cmd = sys.argv[1] if len(sys.argv) > 1 else "cast"
    {"cast": cast, "status": status, "gaze": gaze}[cmd]()
```

---

## SPELL 2 â€” FORBIDDANCE

### D&D Spell Details

| Field | Value |
|-------|-------|
| **Name** | Forbiddance |
| **School** | Abjuration |
| **Level** | 6th (Cleric) |
| **Components** | V, S, M (holy water + rare incense, 1500 gp), DF |
| **Duration** | Permanent |
| **Area** | 60-ft cube/level |
| **Effect** | Seals area against planar travel. No teleportation, plane shift, gate, astral/ethereal travel into or within the area. Creatures of opposed alignment take 2d6 damage per round. The area is INVIOLATE. Permanent with material cost. |
| **Epic Upgrade** | Greater Forbiddance â€” extends across demiplanes, covers entire structures. |

### HFO Fit

| Field | Value |
|-------|-------|
| **Commander** | Web Weaver â€” BINDER OF BLOOD AND BREATH |
| **Port** | P1 BRIDGE |
| **Trigram** | â˜¶ Gen (Mountain) â€” keeping still, the bedrock |
| **Strange Loop** | Blood â†’ Breath â†’ Life â†’ Blood |
| **Paradox** | Blood IS breath â€” covenant IS life force |
| **Why This Spell** | The Binder's identity is "nothing crosses without a covenant." Forbiddance is the spell that makes boundaries ABSOLUTE. In HFO: every data crossing point must have a Zod contract. Raw writes that bypass schemas are planar intrusions â€” they damage the system (alignment damage). The Mountain doesn't move. |
| **Existing Ability** | None (P1's first Lvl 1 ability) |

### JADC2 / MOSAIC

| Field | Value |
|-------|-------|
| **MOSAIC Tile** | FUSE |
| **JADC2 Function** | Data Fabric / ABMS (Advanced Battle Management System) |
| **Kill Chain Stage** | Fix â€” ensure target data is correctly bound to the right system |
| **OODA Stage** | Orient â€” structure incoming data against known schemas |
| **C2 Requirement** | Interoperability â€” data crosses boundaries only through contracted interfaces |
| **Military Analog** | IFF (Identify Friend/Foe) â€” nothing enters the coalition net without proper identification |

### HFO Metadata

| Field | Value |
|-------|-------|
| **Script** | `scripts/web_weaver_forbiddance.py` |
| **Pointer Key** | `p1_forbiddance_script` |
| **Artifact Dir** | `artifacts/web_weaver_forbiddance/` |
| **State File** | `forbiddance_state.json` |
| **npm Scripts** | `p1:forbiddance:cast`, `p1:forbiddance:status`, `p1:forbiddance:ward` |
| **Dependencies** | `contracts/*.zod.ts`, `hfo_blackboard_events.py`, `artifacts/ssot_write_audit.jsonl` |
| **Galois Partner** | P6 CLONE (Stage 1: seal boundaries + backup what's inside) |
| **MTG Card Slot** | Static â€” Quick Sliver (flash â€” instant boundary enforcement) |

### Pseudocode

```python
#!/usr/bin/env python3
"""
Ability: FORBIDDANCE | Level: 1 | Frequency: Daily
Commander: Web Weaver (P1 BRIDGE)
"Nothing crosses this boundary without a covenant."
"""
import subprocess, json, os, sys, glob
from pathlib import Path
from datetime import datetime

ARTIFACT_DIR = Path("artifacts/web_weaver_forbiddance")
STATE_FILE = ARTIFACT_DIR / "forbiddance_state.json"
CONTRACTS_DIR = Path("contracts")

# â”€â”€ The 8 Boundaries (wards to check) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
WARDS = [
    {
        "name": "Zod Contract Coverage",
        "check": "zod_coverage",
        "boundary": "TypeScript schema validators exist for data crossing points",
    },
    {
        "name": "CloudEvent Schema",
        "check": "cloudevent_schema",
        "boundary": "Blackboard events follow CloudEvent spec with Zod validation",
    },
    {
        "name": "SSOT Write Audit",
        "check": "ssot_write_audit",
        "boundary": "Every SSOT write is logged in the audit trail",
    },
    {
        "name": "Pointer Contract",
        "check": "pointer_contract",
        "boundary": "Blessed pointers are the ONLY path resolution mechanism",
    },
    {
        "name": "Header Schema",
        "check": "header_schema",
        "boundary": "Gold artifacts carry validated HFO v3 headers",
    },
    {
        "name": "Agent Mode Inheritance",
        "check": "agent_mode_inheritance",
        "boundary": "Agent modes declare 'inherits: AGENTS.md governance_spine'",
    },
    {
        "name": "Forge Path Gate",
        "check": "forge_path_gate",
        "boundary": "Files in forge directories follow medallion placement rules",
    },
    {
        "name": "Cantrip Dispatch Contract",
        "check": "cantrip_dispatch",
        "boundary": "Cantrip scripts are registered in the 8x8 dispatcher matrix",
    },
]

def _check_zod_coverage():
    """Ward 0: How many Zod contracts exist?"""
    zod_files = list(CONTRACTS_DIR.glob("*.zod.ts"))
    # Cross-reference: which data types have contracts?
    contracted = [f.stem.replace(".zod", "") for f in zod_files]
    return {
        "pass": len(zod_files) >= 8,
        "count": len(zod_files),
        "contracted": contracted[:10],
    }

def _check_cloudevent_schema():
    """Ward 1: Does blackboard event emitter use structured schema?"""
    bb_path = Path("hfo_blackboard_events.py")
    if not bb_path.exists():
        return {"pass": False, "reason": "hfo_blackboard_events.py not found"}
    content = bb_path.read_text()
    has_type = "type" in content and "source" in content
    has_spec = "specversion" in content or "cloudevents" in content.lower()
    return {"pass": has_type and has_spec, "has_type_source": has_type,
            "has_spec": has_spec}

def _check_ssot_write_audit():
    """Ward 2: Does SSOT write audit trail exist and have recent entries?"""
    audit_path = Path("artifacts/ssot_write_audit.jsonl")
    if not audit_path.exists():
        return {"pass": False, "reason": "No write audit trail"}
    lines = audit_path.read_text().strip().splitlines()
    return {"pass": len(lines) > 0, "entries": len(lines)}

def _check_pointer_contract():
    """Ward 3: Are blessed pointers the canonical resolution path?"""
    blessed = Path("hfo_pointers_blessed.json")
    if not blessed.exists():
        return {"pass": False, "reason": "No blessed pointer registry"}
    data = json.loads(blessed.read_text())
    total_paths = sum(
        len(d.get("paths", {})) for d in data.get("domains", {}).values()
    )
    return {"pass": total_paths >= 100, "total_blessed_paths": total_paths}

def _check_header_schema():
    """Ward 4: Do gold artifacts carry HFO v3 headers?"""
    result = subprocess.run(
        ["python3", "scripts/hfo_gold_semantic_location_gate.py", "--json"],
        capture_output=True, text=True, timeout=30
    )
    return {"pass": result.returncode == 0, "exit_code": result.returncode}

def _check_agent_mode_inheritance():
    """Ward 5: Do agent modes declare governance inheritance?"""
    modes = list(Path(".github/agents").glob("*.agent.md"))
    inheriting = 0
    for mode in modes[:20]:  # Sample first 20
        content = mode.read_text(errors="ignore")
        if "inherits" in content.lower() or "governance" in content.lower():
            inheriting += 1
    return {"pass": inheriting > 0, "sampled": min(len(modes), 20),
            "inheriting": inheriting, "total_modes": len(modes)}

def _check_forge_path_gate():
    """Ward 6: Are forge paths structurally valid?"""
    forge_dirs = ["hfo_hot_obsidian_forge", "hfo_cold_obsidian_forge",
                  "hot_obsidian_forge", "cold_obsidian_forge"]
    existing = [d for d in forge_dirs if Path(d).exists()]
    return {"pass": len(existing) >= 2, "existing_forges": existing}

def _check_cantrip_dispatch():
    """Ward 7: Are cantrips registered in dispatcher?"""
    cantrip_dir = Path("scripts/cantrips")
    if not cantrip_dir.exists():
        return {"pass": False, "reason": "No cantrip directory"}
    cantrips = list(cantrip_dir.glob("*.sh"))
    return {"pass": len(cantrips) >= 8, "registered": len(cantrips)}

def cast():
    """Cast FORBIDDANCE â€” check all 8 boundary wards."""
    ARTIFACT_DIR.mkdir(parents=True, exist_ok=True)
    checks = {
        "zod_coverage": _check_zod_coverage,
        "cloudevent_schema": _check_cloudevent_schema,
        "ssot_write_audit": _check_ssot_write_audit,
        "pointer_contract": _check_pointer_contract,
        "header_schema": _check_header_schema,
        "agent_mode_inheritance": _check_agent_mode_inheritance,
        "forge_path_gate": _check_forge_path_gate,
        "cantrip_dispatch": _check_cantrip_dispatch,
    }

    print("=" * 66)
    print("  FORBIDDANCE â€” Web Weaver's Boundary Enforcement (Lvl 1)")
    print("  Nothing crosses without a covenant.")
    print("=" * 66)

    results = []
    for ward in WARDS:
        check_fn = checks[ward["check"]]
        try:
            result = check_fn()
            passed = result.get("pass", False)
        except Exception as e:
            result = {"pass": False, "error": str(e)}
            passed = False
        icon = "ðŸ›¡ï¸" if passed else "âš ï¸"
        print(f"\n  {icon} Ward: {ward['name']}")
        print(f"     Covenant: {ward['boundary']}")
        status_msg = "SEALED" if passed else f"BREACHED â€” {result}"
        print(f"     Status:  {status_msg}")
        results.append({"ward": ward["name"], "passed": passed, **result})

    sealed = sum(1 for r in results if r["passed"])
    health = "INVIOLATE" if sealed == 8 else "WARDED" if sealed >= 6 else "POROUS" if sealed >= 4 else "BREACHED"

    print(f"\n{'â”€' * 66}")
    print(f"  Boundary: {health} ({sealed}/8 wards sealed)")
    print("=" * 66)

    state = {"cast_at": datetime.utcnow().isoformat() + "Z", "health": health,
             "sealed": sealed, "total": 8, "results": results}
    STATE_FILE.write_text(json.dumps(state, indent=2, default=str))

if __name__ == "__main__":
    cmd = sys.argv[1] if len(sys.argv) > 1 else "cast"
    {"cast": cast, "status": lambda: print(json.dumps(
        json.loads(STATE_FILE.read_text()), indent=2) if STATE_FILE.exists()
        else print("No cast found")),
     "ward": cast}[cmd]()
```

---

## SPELL 3 â€” GENESIS

### D&D Spell Details

| Field | Value |
|-------|-------|
| **Name** | Genesis |
| **School** | Conjuration (Creation) |
| **Level** | **Epic** (Epic Level Handbook, p. 26) |
| **Spellcraft DC** | 55 |
| **Components** | V, S, XP (5,000 XP) |
| **Casting Time** | Special (creation takes weeks) |
| **Duration** | Instantaneous (demiplane is permanent) |
| **Effect** | Creates a finite demiplane. You define traits: gravity, time flow, morphic quality, elemental/energy traits, alignment traits. The plane is REAL, permanent, and independently existing. You can modify it with subsequent castings. |

### HFO Fit

| Field | Value |
|-------|-------|
| **Commander** | Mirror Magus â€” MAKER OF MYTHS AND MEANING |
| **Port** | P2 SHAPE |
| **Trigram** | â˜µ Kan (Water) â€” the abyss, dangerous depth where creation hides |
| **Strange Loop** | Myths â†’ Meaning â†’ New Myths â†’ New Meaning |
| **Paradox** | Myths ARE meaning â€” the fiction IS the deepest truth |
| **Why This Spell** | The ONLY epic-level spell in the octave. The Demiurge creates REALITIES, not objects. Every Gen (7, 8, 9, 10) is a demiplane with defined physics (contracts, pointers, gates). Genesis is creation at the deepest level â€” not "make a function" but "make a WORLD with its own rules." |
| **Existing Ability** | None (P2's first Lvl 1 ability) |

### JADC2 / MOSAIC

| Field | Value |
|-------|-------|
| **MOSAIC Tile** | SHAPE |
| **JADC2 Function** | Force Design â€” create task-organized packages for specific missions |
| **Kill Chain Stage** | Plan â€” architect the operational environment |
| **OODA Stage** | Decide â€” choose the reality you want to create |
| **C2 Requirement** | Composability â€” create new force packages from validated templates |
| **Military Analog** | Theater creation â€” standing up a new AOR (Area of Responsibility) with its own C2 structure |

### HFO Metadata

| Field | Value |
|-------|-------|
| **Script** | `scripts/mirror_magus_genesis.py` |
| **Pointer Key** | `p2_genesis_script` |
| **Artifact Dir** | `artifacts/mirror_magus_genesis/` |
| **State File** | `genesis_state.json` |
| **npm Scripts** | `p2:genesis:cast`, `p2:genesis:status`, `p2:genesis:survey` |
| **Dependencies** | `hfo_pointers_blessed.json`, `package.json`, `contracts/`, templates |
| **Galois Partner** | P5 CONTINGENCY (Stage 2: create the world + arm its self-healing) |
| **MTG Card Slot** | Activated â€” Sliver Queen (produce 1/1 tokens â€” creation factory) |

### Pseudocode

```python
#!/usr/bin/env python3
"""
Ability: GENESIS | Level: 1 | Frequency: Daily
Commander: Mirror Magus (P2 SHAPE)
"I create a new reality with defined physics."
"""
import subprocess, json, os, sys
from pathlib import Path
from datetime import datetime

ARTIFACT_DIR = Path("artifacts/mirror_magus_genesis")
STATE_FILE = ARTIFACT_DIR / "genesis_state.json"

# â”€â”€ The Demiplane Registry (existing worlds) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def _discover_demiplanes():
    """Find all Gen/Omega project directories (each is a demiplane)."""
    candidates = [
        ("Gen7", "hfo_hot_obsidian_forge/1_silver/0_projects/omega_gen7"),
        ("Gen8", "hfo_hot_obsidian_forge/1_silver/0_projects/omega_gen8_production"),
        ("Gen10", "hfo_hot_obsidian_forge/1_silver/0_projects/omega_gen10"),
    ]
    planes = []
    for name, path in candidates:
        p = Path(path)
        if p.exists():
            has_package = (p / "package.json").exists() or (p / "app").exists()
            has_tests = any(p.rglob("*.spec.ts"))
            planes.append({
                "name": name, "path": str(p), "exists": True,
                "has_package": has_package, "has_tests": has_tests,
                "file_count": sum(1 for _ in p.rglob("*") if _.is_file()),
            })
    return planes

def _check_plane_physics(plane):
    """Validate a demiplane has defined physics (contracts, tests, structure)."""
    path = Path(plane["path"])
    physics = {
        "has_html": any(path.rglob("*.html")),
        "has_js": any(path.rglob("*.js")),
        "has_css": any(path.rglob("*.css")),
        "has_tests": plane.get("has_tests", False),
        "has_config": (path / "netlify.toml").exists() or plane.get("has_package"),
    }
    defined_count = sum(1 for v in physics.values() if v)
    return {"plane": plane["name"], "physics": physics,
            "defined_traits": defined_count, "total_traits": len(physics)}

def cast():
    """Cast GENESIS â€” survey all demiplanes and their physics."""
    ARTIFACT_DIR.mkdir(parents=True, exist_ok=True)

    print("=" * 66)
    print("  GENESIS â€” Mirror Magus's Demiplane Survey (Lvl 1)")
    print("  I create new realities with defined physics.")
    print("=" * 66)

    planes = _discover_demiplanes()
    print(f"\n  Demiplanes discovered: {len(planes)}")

    results = []
    for plane in planes:
        physics = _check_plane_physics(plane)
        defined = physics["defined_traits"]
        total = physics["total_traits"]
        icon = "ðŸŒ" if defined >= 4 else "ðŸŒ‘" if defined >= 2 else "âš«"
        print(f"\n  {icon} {plane['name']}: {plane['path']}")
        print(f"     Files: {plane['file_count']}")
        print(f"     Physics: {defined}/{total} traits defined")
        for trait, val in physics["physics"].items():
            mark = "âœ“" if val else "âœ—"
            print(f"       {mark} {trait}")
        results.append(physics)

    healthy = sum(1 for r in results if r["defined_traits"] >= 4)
    status_word = "COSMOGONIC" if healthy == len(results) else "NASCENT"

    print(f"\n{'â”€' * 66}")
    print(f"  Creation Status: {status_word} ({healthy}/{len(results)} planes fully defined)")
    print("=" * 66)

    state = {"cast_at": datetime.utcnow().isoformat() + "Z", "status": status_word,
             "planes": len(results), "healthy": healthy, "results": results}
    STATE_FILE.write_text(json.dumps(state, indent=2, default=str))

if __name__ == "__main__":
    cmd = sys.argv[1] if len(sys.argv) > 1 else "cast"
    {"cast": cast, "status": lambda: print(json.dumps(
        json.loads(STATE_FILE.read_text()), indent=2) if STATE_FILE.exists()
        else print("No cast found")),
     "survey": cast}[cmd]()
```

---

## SPELL 4 â€” GATE

### D&D Spell Details

| Field | Value |
|-------|-------|
| **Name** | Gate |
| **School** | Conjuration (Creation or Calling) |
| **Level** | 9th (Cleric/Sorcerer-Wizard) |
| **Components** | V, S, XP (optional, for calling) |
| **Duration** | Concentration (1 round/level) or instantaneous |
| **Effect** | Opens a portal to a specific point on another plane. Two modes: (1) Travel â€” two-way portal, anything can walk through. (2) Calling â€” name a specific creature, it is drawn through and must serve. |

### HFO Fit

| Field | Value |
|-------|-------|
| **Commander** | Harmonic Hydra â€” HARBINGER OF HARMONY AND HAVOC |
| **Port** | P3 INJECT |
| **Trigram** | â˜´ Xun (Wind) â€” penetrating, entering everywhere |
| **Strange Loop** | Harmony â†’ Havoc â†’ New Order â†’ Harmony |
| **Paradox** | Harmony IS havoc â€” perfect delivery is an earthquake to the receiver |
| **Why This Spell** | The Herald IS the portal. Gate has two modes: Travel (deploy to prod) and Calling (pull a specific artifact through). Wind penetrates every crack. The Hydra's many mouths = many delivery corridors speaking in concert. Two-way = rollback corridor (Hibernation Sliver). |
| **Existing Ability** | None (P3's first Lvl 1 ability) |

### JADC2 / MOSAIC

| Field | Value |
|-------|-------|
| **MOSAIC Tile** | DELIVER |
| **JADC2 Function** | Effects Delivery â€” precision payload on target |
| **Kill Chain Stage** | Engage â€” deliver effects through the corridor |
| **OODA Stage** | Act â€” execute the decision |
| **C2 Requirement** | Fires integration â€” right payload through right corridor at right time |
| **Military Analog** | Logistics corridor â€” from depot to forward operating base |

### HFO Metadata

| Field | Value |
|-------|-------|
| **Script** | `scripts/harmonic_hydra_gate.py` |
| **Pointer Key** | `p3_gate_script` |
| **Artifact Dir** | `artifacts/harmonic_hydra_gate/` |
| **State File** | `gate_state.json` |
| **npm Scripts** | `p3:gate:cast`, `p3:gate:status`, `p3:gate:open` |
| **Dependencies** | `artifacts/flight/`, `netlify.toml`, `scripts/cantrips/`, `hfo_blackboard_events.py` |
| **Galois Partner** | P4 WEIRD (Stage 3: open corridor + attack what comes through) |
| **MTG Card Slot** | Static â€” The First Sliver (cascade â€” chain delivery) |

### Pseudocode

```python
#!/usr/bin/env python3
"""
Ability: GATE | Level: 1 | Frequency: Daily
Commander: Harmonic Hydra (P3 INJECT)
"The portal opens. The payload crosses. The corridor holds."
"""
import subprocess, json, os, sys
from pathlib import Path
from datetime import datetime

ARTIFACT_DIR = Path("artifacts/harmonic_hydra_gate")
STATE_FILE = ARTIFACT_DIR / "gate_state.json"

# â”€â”€ The 8 Corridors (delivery channels to validate) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CORRIDORS = [
    {"name": "Netlify Deploy", "check": "netlify",
     "plane": "Production (public web)"},
    {"name": "Git Push", "check": "git_push",
     "plane": "Remote repository"},
    {"name": "Cantrip Dispatch", "check": "cantrip",
     "plane": "Internal tooling (64 cantrips)"},
    {"name": "CloudEvent Emit", "check": "cloudevent",
     "plane": "Blackboard stigmergy"},
    {"name": "Flight Receipt", "check": "flight",
     "plane": "Preflight/Postflight pipeline"},
    {"name": "SSOT Write", "check": "ssot_write",
     "plane": "Memory persistence"},
    {"name": "Forge Medallion", "check": "forge_medal",
     "plane": "Bronzeâ†’Silverâ†’Gold promotion path"},
    {"name": "Agent Mode Deploy", "check": "agent_mode",
     "plane": "Agent shapeshifting library"},
]

def _check_netlify():
    """Is the Netlify deployment corridor configured?"""
    config = Path("netlify.toml")
    return {"pass": config.exists(), "config_exists": config.exists()}

def _check_git_push():
    """Is git configured with a remote?"""
    result = subprocess.run(["git", "remote", "-v"],
                            capture_output=True, text=True, timeout=5)
    has_remote = len(result.stdout.strip()) > 0
    return {"pass": has_remote, "remotes": result.stdout.strip()[:100]}

def _check_cantrip():
    """Are cantrip scripts registered?"""
    cantrip_dir = Path("scripts/cantrips")
    scripts = list(cantrip_dir.glob("*.sh")) if cantrip_dir.exists() else []
    return {"pass": len(scripts) >= 8, "count": len(scripts)}

def _check_cloudevent():
    """Is CloudEvent emitter operational?"""
    bb = Path("hfo_blackboard_events.py")
    return {"pass": bb.exists() and bb.stat().st_size > 100}

def _check_flight():
    """Are flight receipts being generated?"""
    flight = Path("artifacts/flight")
    receipts = list(flight.glob("*.json")) if flight.exists() else []
    return {"pass": len(receipts) > 0, "count": len(receipts)}

def _check_ssot_write():
    """Is SSOT write path operational?"""
    audit = Path("artifacts/ssot_write_audit.jsonl")
    return {"pass": audit.exists(), "exists": audit.exists()}

def _check_forge_medal():
    """Do forge directories exist for medallion promotion?"""
    forges = [Path(f"hfo_hot_obsidian_forge/{d}") for d in
              ["0_bronze", "1_silver", "2_gold"]]
    existing = [f for f in forges if f.exists()]
    return {"pass": len(existing) == 3, "existing": len(existing)}

def _check_agent_mode():
    """Are agent modes deployable?"""
    modes = list(Path(".github/agents").glob("*.agent.md"))
    return {"pass": len(modes) > 0, "count": len(modes)}

def cast():
    """Cast GATE â€” validate all delivery corridors."""
    ARTIFACT_DIR.mkdir(parents=True, exist_ok=True)
    checks = {
        "netlify": _check_netlify, "git_push": _check_git_push,
        "cantrip": _check_cantrip, "cloudevent": _check_cloudevent,
        "flight": _check_flight, "ssot_write": _check_ssot_write,
        "forge_medal": _check_forge_medal, "agent_mode": _check_agent_mode,
    }

    print("=" * 66)
    print("  GATE â€” Harmonic Hydra's Delivery Corridor Audit (Lvl 1)")
    print("  The portal opens. The payload crosses.")
    print("=" * 66)

    results = []
    for corridor in CORRIDORS:
        try:
            result = checks[corridor["check"]]()
            passed = result.get("pass", False)
        except Exception as e:
            result = {"pass": False, "error": str(e)}
            passed = False
        icon = "ðŸŒ€" if passed else "ðŸš«"
        print(f"\n  {icon} {corridor['name']} â†’ {corridor['plane']}")
        print(f"     {'OPEN' if passed else 'BLOCKED'}")
        results.append({"corridor": corridor["name"], "passed": passed, **result})

    open_count = sum(1 for r in results if r["passed"])
    health = ("PLANAR" if open_count == 8 else "PARTIAL" if open_count >= 5
              else "CONSTRICTED")

    print(f"\n{'â”€' * 66}")
    print(f"  Corridors: {health} ({open_count}/8 open)")
    print("=" * 66)

    state = {"cast_at": datetime.utcnow().isoformat() + "Z", "health": health,
             "open": open_count, "total": 8, "results": results}
    STATE_FILE.write_text(json.dumps(state, indent=2, default=str))

if __name__ == "__main__":
    cmd = sys.argv[1] if len(sys.argv) > 1 else "cast"
    {"cast": cast, "status": lambda: print(json.dumps(
        json.loads(STATE_FILE.read_text()), indent=2) if STATE_FILE.exists()
        else print("No cast found")),
     "open": cast}[cmd]()
```

---

## SPELL 5 â€” WEIRD

### D&D Spell Details

| Field | Value |
|-------|-------|
| **Name** | Weird |
| **School** | Illusion (Phantasm, Fear, Mind-Affecting) |
| **Level** | 9th (Sorcerer-Wizard) |
| **Components** | V, S |
| **Duration** | Instantaneous |
| **Range** | Medium (100 ft + 10 ft/level) |
| **Effect** | Targets all creatures in range. Creates phantasmal killers drawn from each target's DEEPEST FEAR. Will save or die. Success: still 3d6 damage + 1d4 turns stunned. The fear is different for every target because it's generated from THEIR mind. |

### HFO Fit

| Field | Value |
|-------|-------|
| **Commander** | Red Regnant â€” SINGER OF STRIFE AND SPLENDOR |
| **Port** | P4 DISRUPT |
| **Trigram** | â˜³ Zhen (Thunder) â€” sudden shock |
| **Strange Loop** | Strife â†’ Splendor â†’ Higher Strife â†’ Higher Splendor |
| **Paradox** | Strife IS splendor â€” what survives the song becomes incandescent |
| **Why This Spell** | The Singer doesn't choose the attack â€” she makes the CODE'S OWN ASSUMPTIONS attack it. Each phantasm is generated FROM the target. Mutation testing: invert constants, swap config, inject boundaries. The fear is always unique because it's shaped by the code's hidden assumptions. FESTERING_ANGER = cumulative grudge tracking. WEIRD = surgical one-time deep probe. |
| **Existing Ability** | FESTERING_ANGER (Lvl 1 â€” cumulative grudge sweep) |

### JADC2 / MOSAIC

| Field | Value |
|-------|-------|
| **MOSAIC Tile** | DISRUPT |
| **JADC2 Function** | Red Team / Adversarial Assessment |
| **Kill Chain Stage** | Assess â€” evaluate target's actual vulnerability |
| **OODA Stage** | Orient â†’ Decide â€” reframe understanding through adversarial lens |
| **C2 Requirement** | Force testing â€” validate readiness by attacking own forces |
| **Military Analog** | OPFOR (Opposing Force) â€” exercises where the enemy is shaped by YOUR doctrine, revealing YOUR gaps |

### HFO Metadata

| Field | Value |
|-------|-------|
| **Script** | `scripts/red_regnant_weird.py` |
| **Pointer Key** | `p4_weird_script` |
| **Artifact Dir** | `artifacts/red_regnant_weird/` |
| **State File** | `weird_state.json` |
| **npm Scripts** | `p4:weird:cast`, `p4:weird:status`, `p4:weird:nightmare` |
| **Dependencies** | `scripts/festering_anger_sweep.py`, SSOT DB, `contracts/`, test specs |
| **Galois Partner** | P3 GATE (Stage 3: attack what the corridor delivers) |
| **MTG Card Slot** | Activated â€” Necrotic Sliver (destroy target permanent â€” surgical deletion) |

### Pseudocode

```python
#!/usr/bin/env python3
"""
Ability: WEIRD | Level: 1 | Frequency: Daily
Commander: Red Regnant (P4 DISRUPT)
"Your deepest fear, made real."
"""
import subprocess, json, os, sys, re
from pathlib import Path
from datetime import datetime

ARTIFACT_DIR = Path("artifacts/red_regnant_weird")
STATE_FILE = ARTIFACT_DIR / "weird_state.json"

# â”€â”€ Phantasm Types (each targets a different assumption) â”€â”€â”€â”€â”€â”€â”€
PHANTASMS = [
    {
        "name": "Hardcoded Path Phantasm",
        "target": "Code that assumes a specific file path without pointer resolution",
        "method": "grep for absolute paths not wrapped in resolve()",
    },
    {
        "name": "Magic Number Phantasm",
        "target": "Unconstrained numeric constants (thresholds, limits, timeouts)",
        "method": "grep for bare integers in conditionals without named constants",
    },
    {
        "name": "Silent Failure Phantasm",
        "target": "Exception handlers that pass or continue without logging",
        "method": "grep for 'except.*pass' or 'except.*continue' patterns",
    },
    {
        "name": "Stale Import Phantasm",
        "target": "Imports of modules that no longer exist or have moved",
        "method": "compile check all Python files, watch for ImportError",
    },
    {
        "name": "Orphan Script Phantasm",
        "target": "Scripts referenced in npm but file doesn't exist",
        "method": "cross-reference package.json scripts with filesystem",
    },
    {
        "name": "Uncontracted Schema Phantasm",
        "target": "JSON/YAML data structures written without Zod validation",
        "method": "find .json writes not covered by a contracts/*.zod.ts file",
    },
    {
        "name": "Dead Pointer Phantasm",
        "target": "Blessed pointers resolving to deleted/moved files",
        "method": "verify_hfo_pointers_blessed.py",
    },
    {
        "name": "Assumption Inversion Phantasm",
        "target": "Boolean flags assumed True that may be False in production",
        "method": "find feature flags with defaults that differ from .env.example",
    },
]

def _hunt_hardcoded_paths():
    """Phantasm 0: Find hardcoded absolute paths in Python scripts."""
    hits = []
    for py in Path("scripts").glob("*.py"):
        content = py.read_text(errors="ignore")
        for i, line in enumerate(content.splitlines(), 1):
            if "/home/" in line and "resolve" not in line and "#" not in line.split("/home/")[0]:
                hits.append({"file": str(py), "line": i, "text": line.strip()[:80]})
    return {"pass": len(hits) == 0, "hits": hits[:5], "total": len(hits)}

def _hunt_magic_numbers():
    """Phantasm 1: Find bare magic numbers in conditionals."""
    hits = []
    pattern = re.compile(r'(?:if|elif|while|>=|<=|>|<|==)\s*\d{2,}')
    for py in Path("scripts").glob("*.py"):
        for i, line in enumerate(py.read_text(errors="ignore").splitlines(), 1):
            if pattern.search(line) and "port" not in line.lower():
                hits.append({"file": str(py), "line": i})
    return {"pass": len(hits) < 5, "hits": len(hits)}

def _hunt_silent_failures():
    """Phantasm 2: Find except-pass patterns."""
    hits = []
    for py in list(Path("scripts").glob("*.py")) + list(Path(".").glob("*.py")):
        lines = py.read_text(errors="ignore").splitlines()
        for i, line in enumerate(lines, 1):
            stripped = line.strip()
            if stripped == "pass" and i > 1:
                prev = lines[i-2].strip() if i >= 2 else ""
                if prev.startswith("except"):
                    hits.append({"file": str(py), "line": i})
    return {"pass": len(hits) < 3, "silent_handlers": len(hits)}

def _hunt_stale_imports():
    """Phantasm 3: Compile-check all key Python files."""
    errors = []
    key_files = list(Path("scripts").glob("*.py"))[:20] + list(Path(".").glob("hfo_*.py"))
    for py in key_files:
        r = subprocess.run(["python3", "-m", "py_compile", str(py)],
                           capture_output=True, text=True)
        if r.returncode != 0:
            errors.append({"file": str(py), "error": r.stderr.strip()[:100]})
    return {"pass": len(errors) == 0, "errors": errors}

def _hunt_orphan_scripts():
    """Phantasm 4: npm scripts pointing to missing files."""
    pkg = json.loads(Path("package.json").read_text())
    scripts = pkg.get("scripts", {})
    orphans = []
    for name, cmd in scripts.items():
        # Extract python3/node file references
        for token in cmd.split():
            if token.endswith(".py") or token.endswith(".mjs") or token.endswith(".sh"):
                if not Path(token).exists():
                    orphans.append({"npm_script": name, "missing_file": token})
    return {"pass": len(orphans) == 0, "orphans": orphans[:5], "total": len(orphans)}

def _hunt_dead_pointers():
    """Phantasm 6: Run pointer verification."""
    r = subprocess.run(["python3", "scripts/verify_hfo_pointers_blessed.py"],
                       capture_output=True, text=True, timeout=30)
    return {"pass": r.returncode == 0, "exit_code": r.returncode}

def _hunt_assumption_inversions():
    """Phantasm 7: Feature flags with mismatched defaults."""
    env_file = Path("feature_flags.env")
    example = Path("feature_flags.env.example")
    if not env_file.exists() or not example.exists():
        return {"pass": True, "note": "No feature flags to check"}
    env_vals = dict(l.split("=", 1) for l in env_file.read_text().splitlines()
                    if "=" in l and not l.startswith("#"))
    ex_vals = dict(l.split("=", 1) for l in example.read_text().splitlines()
                   if "=" in l and not l.startswith("#"))
    mismatches = {k: {"env": env_vals.get(k), "example": ex_vals.get(k)}
                  for k in set(env_vals) | set(ex_vals)
                  if env_vals.get(k) != ex_vals.get(k)}
    return {"pass": len(mismatches) < 3, "mismatches": len(mismatches)}

def cast():
    """Cast WEIRD â€” unleash all phantasms."""
    ARTIFACT_DIR.mkdir(parents=True, exist_ok=True)
    hunters = {
        0: _hunt_hardcoded_paths, 1: _hunt_magic_numbers,
        2: _hunt_silent_failures, 3: _hunt_stale_imports,
        4: _hunt_orphan_scripts, 6: _hunt_dead_pointers,
        7: _hunt_assumption_inversions,
    }

    print("=" * 66)
    print("  WEIRD â€” Red Regnant's Assumption Attack (Lvl 1)")
    print("  Your deepest fear, made real.")
    print("=" * 66)

    results = []
    for i, phantasm in enumerate(PHANTASMS):
        hunter = hunters.get(i)
        if hunter is None:
            result = {"pass": True, "note": "Hunter not yet implemented"}
        else:
            try:
                result = hunter()
            except Exception as e:
                result = {"pass": False, "error": str(e)}
        passed = result.get("pass", False)
        icon = "ðŸ’€" if not passed else "âœ¨"
        print(f"\n  {icon} Phantasm {i}: {phantasm['name']}")
        print(f"     Target: {phantasm['target']}")
        print(f"     {'SURVIVED' if passed else 'KILLED â€” fear manifested'}")
        results.append({"phantasm": phantasm["name"], "survived": passed, **result})

    survived = sum(1 for r in results if r["survived"])
    killed = len(results) - survived
    status_word = ("INCANDESCENT" if killed == 0 else "BLOODIED" if killed <= 2
                   else "TERRIFIED" if killed <= 4 else "ANNIHILATED")

    print(f"\n{'â”€' * 66}")
    print(f"  Result: {status_word} ({survived}/8 survived, {killed} fears manifested)")
    print("  What survives the song becomes splendor.")
    print("=" * 66)

    state = {"cast_at": datetime.utcnow().isoformat() + "Z", "status": status_word,
             "survived": survived, "killed": killed, "results": results}
    STATE_FILE.write_text(json.dumps(state, indent=2, default=str))

if __name__ == "__main__":
    cmd = sys.argv[1] if len(sys.argv) > 1 else "cast"
    {"cast": cast, "status": lambda: print(json.dumps(
        json.loads(STATE_FILE.read_text()), indent=2) if STATE_FILE.exists()
        else print("No cast found")),
     "nightmare": cast}[cmd]()
```

---

## SPELL 6 â€” CONTINGENCY

### D&D Spell Details

| Field | Value |
|-------|-------|
| **Name** | Contingency |
| **School** | Evocation |
| **Level** | 6th (Sorcerer-Wizard) |
| **Components** | V, S, M (ivory statuette of self, 1500 gp), F |
| **Duration** | 1 day/level or until discharged |
| **Effect** | Store a companion spell (â‰¤ 5th level) that triggers automatically when a defined condition is met. You set both the spell and the trigger. "If I drop below 0 HP â†’ Heal." "If I become invisible â†’ See Invisibility." Set it. Forget it. It fires perfectly when needed. No action. No awareness needed. |

### HFO Fit

| Field | Value |
|-------|-------|
| **Commander** | Pyre Praetorian â€” DANCER OF DEATH AND DAWN |
| **Port** | P5 IMMUNIZE |
| **Trigram** | â˜² Li (Fire) â€” clarity with hollow center |
| **Strange Loop** | Death â†’ Dawn â†’ New Day â†’ New Death |
| **Paradox** | Death IS dawn â€” the fire that kills IS the fire that illuminates |
| **Why This Spell** | The Dancer pre-choreographs responses BEFORE the danger arrives. Contingency is the ultimate "set-and-forget" defensive spell. The response is automatic, instant, and perfectly timed because it was designed at calm, not crisis. PRISMATIC_WALL = the static defense layers. CONTINGENCY = the dynamic auto-responses armed within those layers. |
| **Existing Ability** | PRISMATIC_WALL (Lvl 1 â€” 8-layer defense health) |

### JADC2 / MOSAIC

| Field | Value |
|-------|-------|
| **MOSAIC Tile** | DEFEND |
| **JADC2 Function** | Integrated Air and Missile Defense (IAMD) â€” automated response |
| **Kill Chain Stage** | Engage â†’ Assess (automatic fire-and-assess loop) |
| **OODA Stage** | Act â€” automatic, pre-authorized response to known threat pattern |
| **C2 Requirement** | Autonomous response â€” pre-delegated authority for time-critical defense |
| **Military Analog** | Aegis Combat System â€” automated threat engagement when human response too slow |

### HFO Metadata

| Field | Value |
|-------|-------|
| **Script** | `scripts/pyre_praetorian_contingency.py` |
| **Pointer Key** | `p5_contingency_script` |
| **Artifact Dir** | `artifacts/pyre_praetorian_contingency/` |
| **State File** | `contingency_state.json` |
| **npm Scripts** | `p5:contingency:cast`, `p5:contingency:status`, `p5:contingency:arm` |
| **Dependencies** | `scripts/hfo_governance_gate.py`, `hfo_memory_guardrails.py`, `hfo_gen_88_backups/` |
| **Galois Partner** | P2 GENESIS (Stage 2: protect what was created) |
| **MTG Card Slot** | Trigger â€” Pulmonic Sliver (returns to top of library on death â€” auto-revive loop) |

### Pseudocode

```python
#!/usr/bin/env python3
"""
Ability: CONTINGENCY | Level: 1 | Frequency: Daily
Commander: Pyre Praetorian (P5 IMMUNIZE)
"If X happens, Y fires. I choreographed the response before the battle."
"""
import subprocess, json, os, sys
from pathlib import Path
from datetime import datetime

ARTIFACT_DIR = Path("artifacts/pyre_praetorian_contingency")
STATE_FILE = ARTIFACT_DIR / "contingency_state.json"

# â”€â”€ Armed Contingencies (if X â†’ then Y) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CONTINGENCIES = [
    {
        "name": "Pointer Drift â†’ Auto-Verify",
        "trigger": "Any blessed pointer resolves to missing file",
        "response": "python3 scripts/verify_hfo_pointers_blessed.py",
        "response_type": "diagnostic",
        "armed": True,
    },
    {
        "name": "SSOT Anomaly â†’ Auto-Backup",
        "trigger": "SSOT alive count drops by >100 in 24 hours",
        "response": "bash hfo_gen_88_backups/hfo_backup.sh",
        "response_type": "protective",
        "armed": True,
    },
    {
        "name": "Governance Gate Fail 3Ã— â†’ Book of Blood",
        "trigger": "Same governance violation appears 3 consecutive sessions",
        "response": "Write to Book of Blood as recurring grudge",
        "response_type": "escalation",
        "armed": True,
    },
    {
        "name": "Federation Health Fail â†’ Quine Check",
        "trigger": "npm run p5:federation:health returns non-zero",
        "response": "Verify all 4 federation quines exist and are non-empty",
        "response_type": "diagnostic",
        "armed": True,
    },
    {
        "name": "Memory Guardrails Breach â†’ Quarantine",
        "trigger": "hfo_memory_guardrails.py detects corruption pattern",
        "response": "Flag affected memories for manual review",
        "response_type": "protective",
        "armed": True,
    },
    {
        "name": "Playwright Test Fail â†’ Screenshot",
        "trigger": "Any Playwright spec fails",
        "response": "Capture failure screenshot + trace for forensic review",
        "response_type": "diagnostic",
        "armed": True,
    },
    {
        "name": "Agent Choke â†’ Grudge Record",
        "trigger": "Agent fails to complete task (like 8x8 matrix)",
        "response": "Auto-record capacity grudge in SSOT",
        "response_type": "learning",
        "armed": True,
    },
    {
        "name": "Blackboard Silent 24h â†’ Alert",
        "trigger": "No new blackboard events in 24 hours",
        "response": "Emit health warning on next orient",
        "response_type": "diagnostic",
        "armed": False,  # Not yet implemented
    },
]

def _check_trigger(contingency):
    """Check if a contingency's trigger condition is currently active."""
    name = contingency["name"]
    if "Pointer Drift" in name:
        r = subprocess.run(["python3", "scripts/verify_hfo_pointers_blessed.py"],
                           capture_output=True, text=True, timeout=30)
        return {"triggered": r.returncode != 0, "exit_code": r.returncode}
    elif "Governance Gate" in name:
        r = subprocess.run(["python3", "scripts/hfo_governance_gate.py"],
                           capture_output=True, text=True, timeout=30)
        return {"triggered": r.returncode != 0, "exit_code": r.returncode}
    elif "Federation Health" in name:
        r = subprocess.run(["npm", "run", "p5:federation:health"],
                           capture_output=True, text=True, timeout=30)
        return {"triggered": r.returncode != 0, "exit_code": r.returncode}
    elif "Memory Guardrails" in name:
        r = subprocess.run(["python3", "hfo_memory_guardrails.py"],
                           capture_output=True, text=True, timeout=30)
        return {"triggered": r.returncode != 0, "exit_code": r.returncode}
    else:
        return {"triggered": False, "note": "Check not yet automated"}

def cast():
    """Cast CONTINGENCY â€” audit all armed contingencies."""
    ARTIFACT_DIR.mkdir(parents=True, exist_ok=True)

    print("=" * 66)
    print("  CONTINGENCY â€” Pyre Praetorian's Auto-Response Audit (Lvl 1)")
    print("  The response was choreographed before the battle began.")
    print("=" * 66)

    results = []
    for c in CONTINGENCIES:
        armed_icon = "ðŸ”¶" if c["armed"] else "â¬œ"
        trigger_state = _check_trigger(c) if c["armed"] else {"triggered": False}
        triggered = trigger_state.get("triggered", False)
        fire_icon = "ðŸ”¥" if triggered else "ðŸ’¤"

        print(f"\n  {armed_icon} {c['name']}")
        print(f"     Trigger:  {c['trigger']}")
        print(f"     Response: {c['response']}")
        print(f"     Armed: {'YES' if c['armed'] else 'NO'}  |  Status: {fire_icon} {'FIRING' if triggered else 'dormant'}")

        results.append({
            "name": c["name"], "armed": c["armed"],
            "triggered": triggered, "response_type": c["response_type"],
            **trigger_state
        })

    armed_count = sum(1 for c in CONTINGENCIES if c["armed"])
    firing = sum(1 for r in results if r["triggered"])
    health = ("VIGILANT" if firing == 0 else "RESPONDING" if firing <= 2
              else "UNDER_SIEGE")

    print(f"\n{'â”€' * 66}")
    print(f"  Contingencies: {armed_count}/8 armed | {firing} currently firing")
    print(f"  Status: {health}")
    print("=" * 66)

    state = {"cast_at": datetime.utcnow().isoformat() + "Z", "health": health,
             "armed": armed_count, "firing": firing, "results": results}
    STATE_FILE.write_text(json.dumps(state, indent=2, default=str))

if __name__ == "__main__":
    cmd = sys.argv[1] if len(sys.argv) > 1 else "cast"
    {"cast": cast, "status": lambda: print(json.dumps(
        json.loads(STATE_FILE.read_text()), indent=2) if STATE_FILE.exists()
        else print("No cast found")),
     "arm": cast}[cmd]()
```

---

## SPELL 7 â€” CLONE

### D&D Spell Details

| Field | Value |
|-------|-------|
| **Name** | Clone |
| **School** | Necromancy |
| **Level** | 8th (Sorcerer-Wizard) |
| **Components** | V, S, M (cube of flesh, laboratory), F (a laboratory) |
| **Duration** | Instantaneous (clone grows over months) |
| **Effect** | Grow a backup body from a flesh sample. If the original dies, the soul transfers to the clone. The clone awakens with all memories and abilities intact, minus one level. The clone body must be maintained. Multiple clones possible. |

### HFO Fit

| Field | Value |
|-------|-------|
| **Commander** | Kraken Keeper â€” DEVOURER OF DEPTHS AND DREAMS |
| **Port** | P6 ASSIMILATE |
| **Trigram** | â˜± Dui (Lake) â€” joyful depth, surface exchange |
| **Strange Loop** | Depths â†’ Dreams â†’ New Depths â†’ New Dreams |
| **Paradox** | Depths ARE dreams â€” what was consumed becomes vision |
| **Why This Spell** | The Devourer's lake holds EVERYTHING â€” including copies of itself. Clone is disaster recovery as identity preservation. The federation quines (Î±/Î©/Î£/Î”) ARE clones â€” any one can regenerate the others. Dregscape Sliver (unearth from graveyard) in mechanical form. The Kraken never truly dies because the depths hold its backup. |
| **Existing Ability** | None (P6's first Lvl 1 ability) |

### JADC2 / MOSAIC

| Field | Value |
|-------|-------|
| **MOSAIC Tile** | STORE |
| **JADC2 Function** | COOP (Continuity of Operations) â€” ensure C2 survives catastrophic loss |
| **Kill Chain Stage** | Sustain â€” maintain operational capability across disruption |
| **OODA Stage** | Orient (recover) â€” re-establish situational awareness from backup |
| **C2 Requirement** | Redundancy â€” no single point of failure destroys capability |
| **Military Analog** | Alternate command post â€” if primary HQ is destroyed, authority transfers to pre-positioned backup with full order of battle |

### HFO Metadata

| Field | Value |
|-------|-------|
| **Script** | `scripts/kraken_keeper_clone.py` |
| **Pointer Key** | `p6_clone_script` |
| **Artifact Dir** | `artifacts/kraken_keeper_clone/` |
| **State File** | `clone_state.json` |
| **npm Scripts** | `p6:clone:cast`, `p6:clone:status`, `p6:clone:verify` |
| **Dependencies** | `hfo_gen_88_backups/hfo_backup.sh`, SSOT DB, federation quines |
| **Galois Partner** | P1 FORBIDDANCE (Stage 1: backup what's inside the sealed boundary) |
| **MTG Card Slot** | Static â€” Dregscape Sliver (unearth â€” return from graveyard) |

### Pseudocode

```python
#!/usr/bin/env python3
"""
Ability: CLONE | Level: 1 | Frequency: Daily
Commander: Kraken Keeper (P6 ASSIMILATE)
"If I die, I wake up in the depths. I always wake up."
"""
import subprocess, json, os, sys, hashlib
from pathlib import Path
from datetime import datetime

ARTIFACT_DIR = Path("artifacts/kraken_keeper_clone")
STATE_FILE = ARTIFACT_DIR / "clone_state.json"

# â”€â”€ The Clone Vats (backup systems to verify) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CLONE_VATS = [
    {
        "name": "SSOT SQLite Backup",
        "check": "ssot_backup",
        "description": "Physical copy of the SSOT database",
    },
    {
        "name": "Î± Quine â€” Doctrine Seed",
        "check": "quine_alpha",
        "description": "Grimoire v11.1 â€” can regenerate the other 3 quines",
        "pointer": "p5_quine_alpha_doctrine_seed",
    },
    {
        "name": "Î© Quine â€” Knowledge Library",
        "check": "quine_omega",
        "description": "Gold Diataxis library â€” cross-references all knowledge",
        "pointer": "p5_quine_omega_knowledge_library",
    },
    {
        "name": "Î£ Quine â€” Memory Engram",
        "check": "quine_sigma",
        "description": "SSOT SQLite â€” all 47k memories",
        "pointer": "p5_quine_sigma_memory_engram",
    },
    {
        "name": "Î” Quine â€” Living Code",
        "check": "quine_delta",
        "description": "Contracts + scripts â€” the executable knowledge",
        "pointer": "p5_quine_delta_living_code",
    },
    {
        "name": "Git Repository",
        "check": "git_repo",
        "description": "Full version history â€” every commit a resurrection point",
    },
    {
        "name": "Blessed Pointer Registry",
        "check": "pointer_registry",
        "description": "hfo_pointers_blessed.json â€” the map to everything",
    },
    {
        "name": "Braided Mission Thread",
        "check": "braided_thread",
        "description": "The YAML SSOT â€” 3274 lines of project state",
    },
]

def _resolve_pointer(key):
    """Resolve a blessed pointer to a path."""
    r = subprocess.run(["python3", "hfo_pointers.py", "resolve", key],
                       capture_output=True, text=True, timeout=5)
    path = r.stdout.strip()
    return path if path and Path(path).exists() else None

def _check_ssot_backup():
    """Vat 0: Does a backup of the SSOT exist?"""
    backup_dir = Path("hfo_gen_88_backups")
    if not backup_dir.exists():
        return {"pass": False, "reason": "No backup directory"}
    backups = list(backup_dir.glob("*.db")) + list(backup_dir.glob("*.tar.gz"))
    return {"pass": len(backups) > 0, "backup_count": len(backups)}

def _check_quine(pointer_key):
    """Check if a federation quine exists and is non-empty."""
    path = _resolve_pointer(pointer_key)
    if not path:
        return {"pass": False, "reason": f"Pointer {pointer_key} unresolvable"}
    p = Path(path)
    size = p.stat().st_size if p.exists() else 0
    return {"pass": size > 100, "path": str(p), "size_bytes": size}

def _check_git_repo():
    """Vat 5: Is git configured with history?"""
    r = subprocess.run(["git", "rev-list", "--count", "HEAD"],
                       capture_output=True, text=True, timeout=5)
    try:
        count = int(r.stdout.strip())
    except ValueError:
        count = 0
    return {"pass": count > 100, "commit_count": count}

def _check_pointer_registry():
    """Vat 6: Does the blessed pointer registry exist and have paths?"""
    p = Path("hfo_pointers_blessed.json")
    if not p.exists():
        return {"pass": False}
    data = json.loads(p.read_text())
    total = sum(len(d.get("paths", {})) for d in data.get("domains", {}).values())
    return {"pass": total >= 100, "total_paths": total}

def _check_braided_thread():
    """Vat 7: Does the braided mission thread exist?"""
    path = _resolve_pointer("braided_mission_thread_alpha_omega_hfo_gen88v8")
    if not path:
        p = Path("braided_mission_thread_alpha_omega_hfo_gen88v8.yaml")
        path = str(p) if p.exists() else None
    if not path:
        return {"pass": False}
    size = Path(path).stat().st_size
    return {"pass": size > 10000, "path": path, "size_bytes": size}

def cast():
    """Cast CLONE â€” verify all backup/resurrection systems."""
    ARTIFACT_DIR.mkdir(parents=True, exist_ok=True)

    print("=" * 66)
    print("  CLONE â€” Kraken Keeper's Disaster Recovery Audit (Lvl 1)")
    print("  If I die, I wake up in the depths. I always wake up.")
    print("=" * 66)

    checks = {
        "ssot_backup": _check_ssot_backup,
        "quine_alpha": lambda: _check_quine("p5_quine_alpha_doctrine_seed"),
        "quine_omega": lambda: _check_quine("p5_quine_omega_knowledge_library"),
        "quine_sigma": lambda: _check_quine("p5_quine_sigma_memory_engram"),
        "quine_delta": lambda: _check_quine("p5_quine_delta_living_code"),
        "git_repo": _check_git_repo,
        "pointer_registry": _check_pointer_registry,
        "braided_thread": _check_braided_thread,
    }

    results = []
    for vat in CLONE_VATS:
        try:
            result = checks[vat["check"]]()
            passed = result.get("pass", False)
        except Exception as e:
            result = {"pass": False, "error": str(e)}
            passed = False
        icon = "ðŸ§¬" if passed else "ðŸ’€"
        print(f"\n  {icon} {vat['name']}")
        print(f"     {vat['description']}")
        print(f"     {'VIABLE â€” clone body healthy' if passed else 'DEGRADED â€” clone compromised'}")
        results.append({"vat": vat["name"], "viable": passed, **result})

    viable = sum(1 for r in results if r["viable"])
    health = ("IMMORTAL" if viable == 8 else "RESILIENT" if viable >= 6
              else "FRAGILE" if viable >= 4 else "MORTAL")

    print(f"\n{'â”€' * 66}")
    print(f"  Clone Status: {health} ({viable}/8 clone vats viable)")
    print(f"  The Devourer {'never truly dies' if viable >= 6 else 'is at risk'}.")
    print("=" * 66)

    state = {"cast_at": datetime.utcnow().isoformat() + "Z", "health": health,
             "viable": viable, "total": 8, "results": results}
    STATE_FILE.write_text(json.dumps(state, indent=2, default=str))

if __name__ == "__main__":
    cmd = sys.argv[1] if len(sys.argv) > 1 else "cast"
    {"cast": cast, "status": lambda: print(json.dumps(
        json.loads(STATE_FILE.read_text()), indent=2) if STATE_FILE.exists()
        else print("No cast found")),
     "verify": cast}[cmd]()
```

---

## SPELL 8 â€” TIME STOP

### D&D Spell Details

| Field | Value |
|-------|-------|
| **Name** | Time Stop |
| **School** | Transmutation |
| **Level** | 9th (Sorcerer-Wizard) |
| **Components** | V |
| **Duration** | 1d4+1 rounds (apparent time) |
| **Effect** | Freeze time for everyone except caster. 1d4+1 rounds of free action. Can move, cast spells, prepare â€” but cannot directly affect other creatures (spells aimed at them end the stop). You exist in a bubble of frozen time, able to assess, position, and prepare. |

### HFO Fit

| Field | Value |
|-------|-------|
| **Commander** | Spider Sovereign â€” SUMMONER OF SILK AND SOVEREIGNTY |
| **Port** | P7 NAVIGATE |
| **Trigram** | â˜° Qian (Heaven) â€” all creative, supreme authority |
| **Strange Loop** | Silk â†’ Sovereignty â†’ More Silk â†’ Greater Sovereignty |
| **Paradox** | Silk IS sovereignty â€” the web you wove IS your authority |
| **Why This Spell** | The Summoner navigates by feeling vibrations on the web. But if the web is vibrating during measurement, the reading is noisy. TIME_STOP freezes ALL vibrations â€” giving a perfect, deterministic snapshot. You can't navigate while the map is being redrawn. WISH = enforcement audit (how much silk is structural?). TIME_STOP = atomic state capture (freeze the web to read it). |
| **Existing Ability** | WISH (Lvl 1 â€” enforcement audit, 70% complete) |

### JADC2 / MOSAIC

| Field | Value |
|-------|-------|
| **MOSAIC Tile** | NAVIGATE |
| **JADC2 Function** | COP (Common Operating Picture) â€” unified snapshot of the battlespace |
| **Kill Chain Stage** | Understand â€” build coherent picture from all sensors |
| **OODA Stage** | Observe+Orient (atomic) â€” capture AND interpret simultaneously |
| **C2 Requirement** | Decision superiority â€” accurate picture at decision time |
| **Military Analog** | SITREP freeze frame â€” everyone reports simultaneously at T=0, creating a single consistent operating picture |

### HFO Metadata

| Field | Value |
|-------|-------|
| **Script** | `scripts/spider_sovereign_time_stop.py` |
| **Pointer Key** | `p7_time_stop_script` |
| **Artifact Dir** | `artifacts/spider_sovereign_time_stop/` |
| **State File** | `time_stop_state.json` |
| **npm Scripts** | `p7:time-stop:cast`, `p7:time-stop:status`, `p7:time-stop:compare` |
| **Dependencies** | `hfo_pointers_blessed.json`, SSOT DB, `package.json`, `hfo_hub.py` |
| **Galois Partner** | P0 TRUE_SEEING (Stage 0: freeze time + see the truth at T=0) |
| **MTG Card Slot** | Activated â€” Sliver Overlord (search library for any sliver â€” supreme asset location) |

### Pseudocode

```python
#!/usr/bin/env python3
"""
Ability: TIME_STOP | Level: 1 | Frequency: Daily
Commander: Spider Sovereign (P7 NAVIGATE)
"Time freezes. The web is still. Every thread legible."
"""
import subprocess, json, os, sys, hashlib
from pathlib import Path
from datetime import datetime

ARTIFACT_DIR = Path("artifacts/spider_sovereign_time_stop")
STATE_FILE = ARTIFACT_DIR / "time_stop_state.json"
SNAPSHOT_DIR = ARTIFACT_DIR / "snapshots"

# â”€â”€ Frozen Dimensions (what to capture at T=0) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DIMENSIONS = [
    {"name": "SSOT", "capture": "ssot_snapshot"},
    {"name": "Pointers", "capture": "pointer_snapshot"},
    {"name": "npm Scripts", "capture": "npm_snapshot"},
    {"name": "Contracts", "capture": "contract_snapshot"},
    {"name": "Agent Modes", "capture": "agent_mode_snapshot"},
    {"name": "Forge Structure", "capture": "forge_snapshot"},
    {"name": "Test Results", "capture": "test_snapshot"},
    {"name": "Git State", "capture": "git_snapshot"},
]

def _resolve_ssot_db():
    r = subprocess.run(["python3", "hfo_pointers.py", "resolve", "mcp_memory_ssot_sqlite"],
                       capture_output=True, text=True)
    return r.stdout.strip()

def _capture_ssot():
    """Freeze SSOT state."""
    import sqlite3
    db = _resolve_ssot_db()
    conn = sqlite3.connect(db)
    alive = conn.execute("SELECT COUNT(*) FROM memories WHERE deleted_at IS NULL").fetchone()[0]
    total = conn.execute("SELECT COUNT(*) FROM memories").fetchone()[0]
    newest = conn.execute("SELECT MAX(updated_at_iso) FROM memories WHERE deleted_at IS NULL").fetchone()[0]
    conn.close()
    return {"alive": alive, "total": total, "newest_update": newest}

def _capture_pointers():
    """Freeze pointer state."""
    data = json.loads(Path("hfo_pointers_blessed.json").read_text())
    total = sum(len(d.get("paths", {})) for d in data.get("domains", {}).values())
    commands = sum(len(d.get("commands", {})) for d in data.get("domains", {}).values())
    return {"total_paths": total, "total_commands": commands,
            "hash": hashlib.sha256(Path("hfo_pointers_blessed.json").read_bytes()).hexdigest()[:16]}

def _capture_npm():
    """Freeze npm script state."""
    pkg = json.loads(Path("package.json").read_text())
    scripts = pkg.get("scripts", {})
    return {"total_scripts": len(scripts),
            "hash": hashlib.sha256(json.dumps(scripts, sort_keys=True).encode()).hexdigest()[:16]}

def _capture_contracts():
    """Freeze contract state."""
    zod_files = list(Path("contracts").glob("*.zod.ts"))
    return {"zod_count": len(zod_files),
            "names": [f.stem for f in zod_files[:10]]}

def _capture_agent_modes():
    """Freeze agent mode state."""
    modes = list(Path(".github/agents").glob("*.agent.md"))
    return {"total_modes": len(modes)}

def _capture_forge():
    """Freeze forge structure."""
    layers = {}
    for layer in ["0_bronze", "1_silver", "2_gold", "3_platinum"]:
        p = Path(f"hfo_hot_obsidian_forge/{layer}")
        if p.exists():
            layers[layer] = sum(1 for _ in p.rglob("*") if _.is_file())
    return {"layers": layers, "total_files": sum(layers.values())}

def _capture_tests():
    """Freeze test state."""
    specs = list(Path("tests").rglob("*.spec.ts"))
    results_dir = Path("test-results")
    last_run = None
    if results_dir.exists():
        items = sorted(results_dir.iterdir(), key=os.path.getmtime, reverse=True)
        if items:
            last_run = datetime.fromtimestamp(os.path.getmtime(items[0])).isoformat()
    return {"spec_count": len(specs), "last_run": last_run}

def _capture_git():
    """Freeze git state."""
    r = subprocess.run(["git", "rev-parse", "HEAD"], capture_output=True, text=True, timeout=5)
    head = r.stdout.strip()[:12]
    r2 = subprocess.run(["git", "rev-list", "--count", "HEAD"], capture_output=True, text=True, timeout=5)
    count = int(r2.stdout.strip()) if r2.returncode == 0 else 0
    r3 = subprocess.run(["git", "status", "--porcelain"], capture_output=True, text=True, timeout=5)
    dirty = len(r3.stdout.strip().splitlines()) if r3.stdout else 0
    return {"head": head, "commit_count": count, "dirty_files": dirty}

def cast():
    """Cast TIME STOP â€” capture atomic snapshot of all dimensions."""
    ARTIFACT_DIR.mkdir(parents=True, exist_ok=True)
    SNAPSHOT_DIR.mkdir(exist_ok=True)

    timestamp = datetime.utcnow()
    snapshot_id = timestamp.strftime("%Y%m%dT%H%M%SZ")

    print("=" * 66)
    print("  TIME STOP â€” Spider Sovereign's Atomic Snapshot (Lvl 1)")
    print("  Time freezes. The web is still. Every thread legible.")
    print("=" * 66)
    print(f"\n  Snapshot ID: {snapshot_id}")
    print(f"  Timestamp:   {timestamp.isoformat()}Z")

    captures = {
        "ssot_snapshot": _capture_ssot,
        "pointer_snapshot": _capture_pointers,
        "npm_snapshot": _capture_npm,
        "contract_snapshot": _capture_contracts,
        "agent_mode_snapshot": _capture_agent_modes,
        "forge_snapshot": _capture_forge,
        "test_snapshot": _capture_tests,
        "git_snapshot": _capture_git,
    }

    frozen = {}
    for dim in DIMENSIONS:
        try:
            data = captures[dim["capture"]]()
        except Exception as e:
            data = {"error": str(e)}
        frozen[dim["name"]] = data
        print(f"\n  â„ï¸  {dim['name']}: captured")
        for k, v in data.items():
            if not isinstance(v, (dict, list)):
                print(f"      {k}: {v}")

    # Save snapshot
    snapshot_file = SNAPSHOT_DIR / f"snapshot_{snapshot_id}.json"
    snapshot = {
        "snapshot_id": snapshot_id,
        "frozen_at": timestamp.isoformat() + "Z",
        "dimensions": frozen,
    }
    snapshot_file.write_text(json.dumps(snapshot, indent=2, default=str))

    # Update latest state
    state = {**snapshot, "snapshot_file": str(snapshot_file)}
    STATE_FILE.write_text(json.dumps(state, indent=2, default=str))

    print(f"\n{'â”€' * 66}")
    print(f"  Time resumes. Snapshot {snapshot_id} preserved.")
    print(f"  Saved to: {snapshot_file}")
    print("=" * 66)

def compare(a=None, b=None):
    """Compare two snapshots (diff between frozen moments)."""
    snapshots = sorted(SNAPSHOT_DIR.glob("snapshot_*.json"))
    if len(snapshots) < 2:
        print("Need at least 2 snapshots to compare. Cast more.")
        return
    s1 = json.loads(snapshots[-2].read_text())
    s2 = json.loads(snapshots[-1].read_text())
    print(f"Comparing: {s1['snapshot_id']} â†’ {s2['snapshot_id']}")
    for dim_name in s1["dimensions"]:
        d1 = s1["dimensions"].get(dim_name, {})
        d2 = s2["dimensions"].get(dim_name, {})
        if d1 != d2:
            print(f"\n  Î” {dim_name}:")
            for key in set(list(d1.keys()) + list(d2.keys())):
                v1, v2 = d1.get(key), d2.get(key)
                if v1 != v2:
                    print(f"    {key}: {v1} â†’ {v2}")

if __name__ == "__main__":
    cmd = sys.argv[1] if len(sys.argv) > 1 else "cast"
    {"cast": cast, "status": lambda: print(json.dumps(
        json.loads(STATE_FILE.read_text()), indent=2) if STATE_FILE.exists()
        else print("No cast found")),
     "compare": compare}[cmd]()
```

---

## Appendix A: The School Isomorphism

The 8 D&D schools mapped to 8 HFO domains is NOT coincidental â€” it's structural:

| D&D School | Core Verb | HFO Port | MOSAIC Tile | Isomorphism |
|-----------|-----------|----------|-------------|-------------|
| Divination | **Know** | P0 | SENSE | Seeing = sensing |
| Abjuration | **Ward** | P1 | FUSE | Warding = boundary enforcement |
| Conjuration | **Create** | P2 | SHAPE | Summoning = creation |
| Conjuration | **Move** | P3 | DELIVER | Portals = delivery corridors |
| Illusion | **Deceive/Test** | P4 | DISRUPT | Phantasms = adversarial probes |
| Evocation | **Trigger** | P5 | DEFEND | Contingent energy = automatic defense |
| Necromancy | **Persist** | P6 | STORE | Death/resurrection = backup/recovery |
| Transmutation | **Change** | P7 | NAVIGATE | Time manipulation = state navigation |

## Appendix B: Daily Ritual (All 11 Spells)

```bash
# â”€â”€ Dawn: The Watcher's Vigil â”€â”€
npm run p0:true-seeing:cast        # Pierce illusions

# â”€â”€ Morning: Oaths and Boundaries â”€â”€
npm run p1:forbiddance:cast        # Seal boundaries
npm run p5:prismatic:cast          # 8-layer defense
npm run p5:contingency:cast        # Auto-response armed?

# â”€â”€ Midday: Creation and Delivery â”€â”€
npm run p2:genesis:cast            # Demiplane health
npm run p3:gate:cast               # Delivery corridors

# â”€â”€ Afternoon: The Song of Strife â”€â”€
npm run p4:festering:sweep:daily   # Grudge sweep
npm run p4:weird:cast              # Assumption attack

# â”€â”€ Evening: Memory and Navigation â”€â”€
npm run p6:clone:cast              # Backup integrity
npm run p7:wish:cast               # Enforcement audit
npm run p7:time-stop:cast          # Freeze for tomorrow
```

---

*Gold Diataxis Reference â€” The OBSIDIAN Octave v1*
*Created: 2026-02-16 | Gen88 | HFO*
*"8 ports. 8 schools. 8 spells. One octave. No gaps."*
