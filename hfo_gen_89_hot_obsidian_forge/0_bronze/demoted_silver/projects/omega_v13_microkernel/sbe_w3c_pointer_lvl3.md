# SBE/ATDD: W3C Pointer Events Level 3 Integration

## Feature: High-Fidelity Pointer Tracking with Coalesced and Predicted Events

**As a** developer building low-latency drawing or tracking applications
**I want** the W3C Pointer Fabric to expose raw high-frequency inputs and Kalman-predicted future inputs
**So that** I can render smooth, zero-latency ink strokes without waiting for the next animation frame, while the main pointer event remains stable and smoothed.

### Background Context
The Omega v13 Microkernel uses a multi-layered defense-in-depth approach:
1. **Havok Physics (Velocnertia Clamp)**: Prevents teleportation of raw coordinates.
2. **Kalman Filter**: Smooths the clamped coordinates to remove sensor jitter.
3. **SCXML FSM**: Enforces strict deny-by-default state transitions (IDLE -> READY -> COMMIT).

W3C Pointer Events Level 3 introduces two key methods:
*   `getCoalescedEvents()`: Returns a sequence of all raw events that were batched into the current dispatched event.
*   `getPredictedEvents()`: Returns a sequence of estimated future events to reduce perceived latency.

### Scenario 1: Exposing Raw High-Frequency Inputs (Coalesced)
**Given** the input harness is producing hand landmarks at 120Hz
**And** the W3C Pointer Fabric is dispatching events at 60Hz (requestAnimationFrame)
**When** the fabric dispatches a `pointermove` event
**Then** the main event's `clientX`/`clientY` should represent the Kalman-smoothed coordinate
**And** calling `event.getCoalescedEvents()` should return an array of synthetic PointerEvents representing the raw, unfiltered coordinates received since the last dispatch.

### Scenario 2: Exposing Low-Latency Future Inputs (Predicted)
**Given** the Kalman filter is tracking the velocity and acceleration of the hand
**When** the fabric dispatches a `pointermove` event
**Then** calling `event.getPredictedEvents()` should return an array of synthetic PointerEvents
**And** these predicted events should be generated by calling `kalmanFilter.predict(step)` for $N$ future steps
**And** the predicted coordinates must not violate the screen bounds.

### Scenario 3: Fallback for Synthetic Events
**Given** standard DOM `PointerEvent` constructors may not fully support injecting `coalescedEvents` and `predictedEvents` arrays in all browser environments
**When** the fabric constructs the synthetic `PointerEvent`
**Then** it must dynamically attach `getCoalescedEvents` and `getPredictedEvents` methods to the event instance before dispatching
**And** these methods must return the correctly formatted arrays of sub-events.

### Scenario 4: Clearing the Buffer
**Given** a `pointermove` event has just been dispatched
**When** the next frame begins
**Then** the internal buffer of coalesced raw events must be cleared
**So that** the next `getCoalescedEvents()` call only contains new data.
